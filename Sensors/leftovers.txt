

/*
#include <fstream>
#include <math.h>
#include <string>
#include <sstream>
#include <string>
#include <unistd.h>
#include <chrono>
#include <ctime>
*/


  const int NUM_ROOMS = 4;
  
  /*
  // generate LCM data structure
  sensor::sensor_data my_data[NUM_ROOMS];
  my_data[0].sendTime = 1.0;
  my_data[3].sendTime = 10.0;
  printf("object 0 time = %f \n", my_data[0].sendTime);
  printf("object 3 time = %f \n", my_data[3].sendTime);
  */
  
  /*

  // get input from command line
  printf("\nThe name of this program is '%s'. \n", argv[0]);
  printf("This program was invoked with %d argument(s). \n", argc - 1);
  if (argc == 1) 
  {
    printf("***error: expecting a data file passed from command line \n");
    return 1;
  }
  printf("\n");




  // initialize the data table
  const int ROWS = 300;
  const int COLS = 3;
  double inData[ROWS][COLS];
  const int MAX_STEPS = 60;
  double waitUsec = 1.0;

  // read in line-by-line of the FDS data
  string filename = argv[1];
  ifstream file(filename.c_str());
  string line;
  double readValue;
  int i, j;
  i = 0;
  while (getline(file, line)) {
    istringstream iss(line);
    j = 0;
    while (iss >> readValue) {
      //cout << "value = " << readValue << " at (" << i << ", " << j << ")" << '\t';
      inData[i][j] = readValue;
      j++;
    }
    i++;
    //cout << endl;
  }
  file.close();

  // generate a data package for each time step
  double outData[COLS];
  for (int iTime = 0; iTime < MAX_STEPS; iTime++) 
  {
    string filename = "update";
    filename = filename + ".dat";
    ofstream myfile;
    myfile.open (filename.c_str());
    for (int jCols = 0; jCols < COLS; jCols++) 
    {
      myfile << inData[iTime][jCols] << "\t" << "\t";
      outData[jCols] = inData[iTime][jCols];
    }
    myfile << "\n";
    myfile.close();
    //cout << "finished step #" << iTime << " with t = " << inData[iTime][0] << endl;
    
    //===============================================================
    // SEND LCM MSG TO MAIN PROGRAM WITH NEW SENSOR DATA    
      // define sensor info in LCM data structure
      my_data.time = outData[0];
      my_data.flux = outData[1];
      my_data.temp = outData[2];
      // print time stamp of message send
      std::chrono::time_point<std::chrono::system_clock> end;
      end = std::chrono::system_clock::now();
      std::time_t end_time = std::chrono::system_clock::to_time_t(end);
      std::cout << "\n   SENSOR sent time " << outData[0] << " at " << std::ctime(&end_time) <<"\n";
      // publish message for the receiver and exit
      lcm.publish("SENSOR", &my_data);
    //===============================================================  
    
    usleep( waitUsec * pow(10.0, 6.0) );
  }
  */
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
OpenMP Work:

/*  OPTION 1
  // simple parallel loop to test for case threads = rooms
  #pragma omp parallel private(pid)
  {
    pid = omp_get_thread_num();
    //std::cout << "  This is process #" << pid << "\n";
    
    sensor::sensor_data my_data;
    my_data.sendTime = pid * 10.0;
    printf("object %d time = %f \n", pid, my_data.sendTime);
    
    usleep( pid * pow(10.0, 6.0) );
    my_data.sendTime = pid * 100.0;
    printf("\nobject %d time = %f \n", pid, my_data.sendTime);
    
  }

  // potentially unnecessary barrier (check this)
  #pragma omp barrier
  */
  
 /*  OPTION 2
  // simple parallel test for when num_threads != num_rooms
  #pragma omp parallel private(pid)
  {
    pid = omp_get_thread_num();
    printf("this is process #%d \n", pid);

    if (pid == 0)
    {
      num_threads = omp_get_num_threads();
      printf("num_threads = %d\n", num_threads);
      if (num_threads != NUM_ROOMS)
      {
        printf("***warning: must set proper number of threads (%d) for %d rooms; use \n", num_threads, NUM_ROOMS);
        printf("$ export OMP_NUM_THREADS=%d \n", NUM_ROOMS);
      }
    }

    #pragma omp for private(i, j, my_file, my_line, readValue)
    for (i = 0; i < NUM_ROOMS; i++)
    {

      my_file = "./data/file" + std::to_string(i) + ".txt";
      printf("%s\n", my_file.c_str());
      std::ifstream if_file(my_file.c_str());

      while (getline(if_file, my_line, ','))
      {
        std::istringstream iss(my_line);
        while (iss >> readValue)
        {
          usleep( 0.5 * pow(10.0, 6.0) );
          printf("thread #%d got value %f in room #%d \n", pid, readValue, i);  
        }
      }

      if_file.close();

      //sensor::sensor_data my_data;
      //my_data.sendTime = pid * 10.0;

      for (j = 0; j < NUM_STEPS; j++)
      {
        //usleep( pid * pow(10.0, 6.0) );
        //printf("  process #%d got room #%d with time %f [%d] \n", pid, i, my_data.sendTime, j);
      }
    }
  }
  */ 
